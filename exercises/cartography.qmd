---
title: "Produire des cartes avec {{< fa brands r-project >}}"
echo: false
number-sections: true
---

::: {.badge}
<a href="https://datalab.sspcloud.fr/launcher/ide/rstudio?autoLaunch=true&init.personalInit=«https%3A%2F%2Fraw.githubusercontent.com%2Flinogaliana%2Fr-geographie%2Fmain%2Fsspcloud%2Finit.sh»&networking.user.enabled=true&onyxia.friendlyName=«rstudio-cours-ENS»" target="_blank" rel="noopener"><img src="https://img.shields.io/badge/Tester%20via%20SSP%20cloud%20-%20SSPCloud?logo=R&labelColor=black&color=%231965b8" alt="Onyxia"></a><br>
:::

<details>
<summary>
Dérouler les _slides_ ci-dessous ou [cliquer ici](/slides/ggplot.qmd)
pour afficher les slides en plein écran.
</summary>


``` {.yaml code-preview="/slides/ggplot.qmd"}
```

</details>


Dans ce TP,
nous allons apprendre à créer des cartes
avec {{< fa brands r-project >}}. A mesure que {{< fa brands r-project >}}
devient incontournable auprès des personnes manipulant des données
spatiales, les solutions pour produire des cartes 
de qualité deviennent de plus en 
plus nombreuses. {{< fa brands r-project >}} a de moins en moins à envier
aux logiciels spécialisés comme QGIS. 

Si vous êtes intéressés par `Python` {{< fa brands python >}},
une version très proche de ce TP est disponible dans [mon cours de l'ENSAE](https://pythonds.linogaliana.fr/content/visualisation/maps.html).


<!----
La pratique de la cartographie se fera, dans la continuité du chapitre
sur les graphiques, en répliquant des cartes qu'on peut trouver sur
la page de l'*open-data* de la ville de Paris 
[ici](https://opendata.paris.fr/explore/dataset/comptage-velo-donnees-compteurs/dataviz/?disjunctive.id_compteur&disjunctive.nom_compteur&disjunctive.id&disjunctive.name).
------>

::: {.callout-note}
Produire de belles cartes demande du temps mais aussi du bon sens. 
Comme toute représentation graphique, il est important de réfléchir au message
à faire passer et aux moyens appropriés.
La sémiologie cartographique, 
une discipline scientifique qui s'intéresse aux messages transmis par les cartes,
propose certaines règles pour éviter de transmettre des messages faussés,
volontairement ou involontairement. 

Certaines peuvent être retrouvées à travers des conseils pratiques
dans
ce [guide de sémiologie cartographique](https://www.insee.fr/fr/statistiques/3640429)
de l'Insee. Celles-ci sont reprises
dans [ce guide](https://juliedjidji.github.io/memocarto/semio.html).

[Cette présentation](https://neocarto.github.io/docs/slides/ENTPE/docs/#/title-slide)
de Nicolas Lambert présente, à partir de nombreux exemples, quelques principes
de la _dataviz_ cartographique.

:::

Ce TP vise à initier:

* Au _package_ [`mapsf`](https://riatelab.github.io/mapsf/),
conçu par les géographiques du RIATE (Paris 7), le _package_ de référence
pour réaliser des cartes avec {{< fa brands r-project >}}
`geoplot` est construit sur `seaborn` et constitue ainsi une extension des graphiques de base.
* Au package [`leaflet`](https://rstudio.github.io/leaflet/) qui est un point d'accès vers la librairie `JavaScript` [leaflet](https://leafletjs.com/) permettant de produire des cartes interactives. Nous approfondirons ultérieurement
les cartes réactives avec un chapitre d'ouverture vers [`Observable`](https://observablehq.com).

Dans ce chapitre, nous allons utiliser les _packages_ suivants:

```{r}
#| output: false
#| echo: true
library(dplyr)
library(sf)
library(stringr)
library(ggplot2)
library(ggmap)
library(cartiflette)
```

## Données

Au cours de ce chapitre, nous allons utiliser
principalement trois jeux de données :

<!-----
* Les comptages de passage de vélos dans les stations de mesure parisiennnes ;
* [La localisation précise des stations](https://parisdata.opendatasoft.com/explore/dataset/comptage-velo-compteurs/download/?format=geojson&timezone=Europe/Berlin&lang=fr)
------>

* Les émissions de gaz à effet de serre estimées au niveau communal par l'`ADEME`. Le jeu de données est
disponible sur [data.gouv](https://www.data.gouv.fr/fr/datasets/inventaire-de-gaz-a-effet-de-serre-territorialise/#_)
et requêtable directement dans {{< fa brands r-project >}} avec
[cet url](https://koumoul.com/s/data-fair/api/v1/datasets/igt-pouvoir-de-rechauffement-global/convert) (ce sera l'objet du premier exercice)[^notedownload].
* Idéalement, on utiliserait directement les données
[disponibles sur le site de l'Insee](https://www.insee.fr/fr/statistiques/3560121) mais celles-ci nécessitent un peu de travail
de nettoyage qui n'entre pas dans le cadre de ce TP. 
Pour faciliter l'import de données Insee, il est recommandé d'utiliser les _packages_
[`doremifasol`](https://github.com/InseeFrLab/DoReMIFaSol) et [`insee`](https://github.com/pyr-opendatafr/R-Insee-Data) qui simplifient l'accès aux données
de l'Insee disponibles sur le site web [insee.fr](https://www.insee.fr/fr/accueil)
ou via des API. 
* Les limites officielles administratives des arrondissements et communes de l'agglomération
parisienne. Ce fonds de carte est produit par l'IGN et sa récupération
est facilitée par le _package_ `cartiflette`.


## Import des données

### Données Filosofi

```{r}
#| output: false
#| echo: true
library(doremifasol)
library(tibble)
filosofi <- as_tibble(
  telechargerDonnees("FILOSOFI_COM", date = 2016)
)
head(filosofi)
```

```{r}
#| echo: false
head(filosofi)
```

::: {.callout-note}
La fonction `as_tibble` nous sert à transformer le _dataframe_ de base (`doremifasol` 
ne fait pas d'_a priori_ sur l'écosystème de manipulation adopté) en 
_dataframe_ adapté à une exploitation via le `tidyverse`. 
:::


### Limites communales et départementales

```{r}
#| eval: false
remotes::install_github("linogaliana/cartiflette-r")
```

```{r}
library(cartiflette)
departement_borders <- download_vectorfile_url_all(
    crs = 4326,
    values = "metropole",
    borders="DEPARTEMENT",
    vectorfile_format="geojson",
    filter_by="FRANCE_ENTIERE",
    source="EXPRESS-COG-CARTO-TERRITOIRE",
    year=2022)
```

```{r}
commune_borders <- download_vectorfile_url_all(
    crs = 4326,
    values = "metropole",
    borders="COMMUNE",
    vectorfile_format="geojson",
    filter_by="FRANCE_ENTIERE",
    source="EXPRESS-COG-CARTO-TERRITOIRE",
    year=2022)
```
commune_borders
::: {.callout-tip}

## Une première carte de la population

1. 


```{r}
library(ggplot2)
ggplot(departement_borders) + geom_sf(fill = "white") + theme_void()
```

```{r}
library(ggplot2)
library(dplyr)
ggplot(commune_borders %>% filter(INSEE_REG == 28)) +
  geom_sf(aes(fill = POPULATION)) +
  theme_void()


population_dep <- commune_borders %>%
  st_drop_geometry() %>%
  group_by(INSEE_DEP) %>%
  summarise(pop = sum(POPULATION)) %>%
  mutate(pop_4 = factor(ntile(pop, 4)))


ggplot(
  departement_borders %>% left_join(population_dep)
) + geom_sf(aes(fill = pop_4)) +
  scale_fill_brewer(palette = "Accent") +
  theme_void()
  
```

:::

# OLD

### Comptages

Un sous-ensemble des données de [Paris _Open Data_](https://opendata.paris.fr/explore/dataset/comptage-velo-donnees-compteurs/information/?disjunctive.id_compteur&disjunctive.nom_compteur&disjunctive.id&disjunctive.name) a été mis à disposition
pour faciliter l'import. 

Il s'agit d'une extraction, qui commence à dater, des données disponibles
sur le site où seules les colonnes
qui servent à cet exercice ont été conservées.

Nous proposons
de télécharger ces données et les enregistrer dans un fichier sur le disque
dur local avant de l'importer[^1]. Cependant, nous n'allons pas faire
cela manuellement mais nous allons plutôt utiliser 
{{< fa brands r-project >}}. Effectuer ce type d'action de manière
manuelle serait une mauvaise pratique du point de vue de la reproductibilité.

```{r}
#| echo: true
#| output: false
url <- "https://minio.lab.sspcloud.fr/projet-formation/diffusion/python-datascientist/bike.csv"
download.file(url, "bike.gz") # <1>
comptages <- readr::read_csv("bike.gz") # <2>
```
1. L'extension `.gz` est importante pour la suite car `readr` en a besoin pour comprendre que le fichier est compressé.
2. Lecture des données avec `read_csv` du package `readr`


[^1]: D'habitude, nous recommandons d'utiliser directement l'URL 
de téléchargement ce qui évite de créer un fichier intermédiaire
sur le disque dur. Néanmoins, ici, l'import direct avec `readr`
ne fonctionnera pas car le fichier est mal interprété par la
librairie. Celle-ci ne comprend pas que le fichier est compressé car
il lui manque l'extension `.gz` (un format compressé) à la fin. 

### Localisation des compteurs

```{r}
#| echo: true
#| output: false
compteurs = st_read("https://parisdata.opendatasoft.com/api/explore/v2.1/catalog/datasets/comptage-velo-compteurs/exports/geojson?lang=fr&timezone=Europe%2FBerlin")
```

Il y a quelques valeurs aberrantes dans ce jeu de données qui doivent
être laissées de côté. Elles sont identifiables par le fait que la variable
`nom_compteurs` ne comporte pas les mentions `Bike IN` ou `Bike OUT`. 
Comme c'est un petit peu avancé pour une introduction, nous donnons
directement la solution de ce travail de nettoyage:

```{r}
#| echo: true
compteurs <- compteurs %>% filter(!str_detect("(Bike IN|Bike OUT)", nom_compteur))
```

### Fonds de carte contextuels

On va utiliser à nouveau `cartiflette` pour récupérer les arrondissements
parisiens et les communes limitrophes. 

```{r}
#| output: false
#| echo: true
arrondissements <- download_vectorfile_url_all(
  crs = 4326,
  values = "75",
  borders="COMMUNE_ARRONDISSEMENT",
  vectorfile_format="geojson",
  filter_by="DEPARTEMENT",
  source="EXPRESS-COG-CARTO-TERRITOIRE",
  year=2022) %>%
  st_transform(2154)
```


## Une première carte avec `ggplot`

Lors des chapitres précédents nous avons appris la manière
dont des graphiques peuvent être construits en accumulant des couches. 

Il est possible d'ajouter des couches sur une image, à condition que
les coordonnées coïncident. Pour faire cela de manière
fiable, nous allons utiliser le package `ggmap`[^statutggmap].

[^statutggmap]: `ggmap` est un _package_ assez ancien qui n'a pas trop évolué récemment. Il continue notamment à utiliser des objets `sp`, l'ancêtre de `sf` qui existe déjà depuis plusieurs années. Il est donc possible que ce _package_ soit archivé dans un futur plus ou moins lointain.

L'objectif du prochain exercice est de construire la carte suivante, de manière progressive:


```{r}
bbox_paris <- arrondissements %>% st_transform(4326) %>% st_bbox()
bbox_paris <- setNames(bbox_paris, c("left", "bottom", "right", "top"))

fonds_stamen <- get_map(
  location = bbox_paris,
  maptype ="watercolor",
  source="stamen")

map_paris_watercolor <- ggmap(fonds_stamen) +
  geom_sf(
    data = arrondissements %>% st_transform(4326),
    fill = "transparent", color = "black",
    inherit.aes = FALSE) +
  geom_sf(data = compteurs, color = "red", inherit.aes = FALSE, size = 4, alpha = 0.4) +
  theme_void()
```

```{r}
map_paris_watercolor
```

::: {.callout-tip}
## Exercice 1: construire la carte des compteurs avec `ggmap` et `ggplot`

Pour récupérer la carte, nous allons avoir besoin de construire un certain
nombre d'objets en amont. En premier lieu, il est nécessaire de créer
un vecteur stockant les extrêmes de notre carte. Dans le jargon des
SIG, cela s'appelle la **_bounding box_**. Voici comment faire ceci:

```{r}
#| echo: true
#| output: false
bbox_paris <- arrondissements %>% st_transform(4326) %>% st_bbox() # <1>
bbox_paris <- setNames(bbox_paris, c("left", "bottom", "right", "top")) # <2>
bbox_paris
```
1. On a besoin de coordonnées en WGS84, il faut donc reprojeter les données avant d'appliquer `st_bbox`
2. `ggmap` attend un vecteur dont les noms sont `"left", "bottom", "right", "top"`, `setNames` permet de renommer les éléments de `bbox_paris` 

```{r}
#| echo: true
bbox_paris
```

1. Utiliser `get_map` pour récupérer le fonds de carte. Nommer l'objet 
`map_paris_watercolor`. La carte proposée utilise le fonds `watercolor`, 
dont la source est `stamen`. Utiliser ensuite `ggmap(fonds_stamen)` 
pour vérifier le fonds de carte récupéré. 

2. Ajouter une couche d'arrondissements à cette image avec `geom_sf`. Il va
être nécessaire d'utiliser les arguments suivants:
+ `data`: comme nous initialisons la figure avec `ggmap`, il faut dire à `ggplot` que nous partons du jeu de données `arrondissements` pour cette couche
+ `fill` et `color` pour contrôler, respectivement, la couleur de l'intérieur et des bordures des polygones.
+ `inherit.aes = FALSE`: indispensable à cause du comportement de `ggmap` qui ne sait pas gérer les objets `sf` (cf. _footnote_ antérieure)

3. Ajouter une couche pour représenter la position des stations avec `geom_sf`. Il va
être nécessaire d'utiliser les arguments suivants:
+ `data`: comme nous initialisons la figure avec `ggmap`, il faut dire à `ggplot` que nous partons du jeu de données `compteurs` pour cette couche
+ `color="red"`, `size=5` et `alpha=0.4` pour contrôler l'apparence de nos points
+ `inherit.aes = FALSE`: indispensable à cause du comportement de `ggmap` qui ne sait pas gérer les objets `sf` (cf. _footnote_ antérieure)
4. Finaliser l'esthétique de la carte avec `theme_void()`


<details>
<summary>
Aide pour la question 1
</summary>
Les arguments à utiliser sont `location`, `maptype` et `source`
</details>
:::


<details>
<summary>
Le fonds de carte, sans motif par dessus, est le suivant:
</summary>
```{r}
# Question 1
fonds_stamen <- get_map(
  location = bbox_paris,
  maptype ="watercolor",
  source="stamen")
map_watercolor_exercice <- ggmap(fonds_stamen)
map_watercolor_exercice
```
</details>

<details>
<summary>
En ajoutant les arrondissements par dessus (question 2):
</summary>
```{r}
# Question 2
map_watercolor_exercice <- map_watercolor_exercice +
  geom_sf(
    data = arrondissements %>% st_transform(4326),
    fill = "transparent", color = "black",
    inherit.aes = FALSE
  )
map_watercolor_exercice
```
</details>

<details>
<summary>
Après avoir ajouté les points (question 3)
</summary>
```{r}
# Question 2
map_watercolor_exercice <- map_watercolor_exercice +
  geom_sf(data = compteurs, color = "red", inherit.aes = FALSE, size = 4, alpha = 0.4) 
map_watercolor_exercice
```
</details>



<details>
<summary>
Si vous préférez un autre fonds de carte que `Watercolor`, par exemple `Stamen Toner`:
</summary>
```{r}
# Question 1
fonds_stamen_toner <- get_map(
  location = bbox_paris,
  maptype ="toner",
  source="stamen")

ggmap(fonds_stamen_toner) +
  geom_sf(
    data = arrondissements %>% st_transform(4326),
    fill = "transparent", color = "blue", linewidth = 0.4,
    inherit.aes = FALSE) +
  geom_sf(data = compteurs, color = "red", inherit.aes = FALSE, size = 4, alpha = 0.4) +
  theme_void()
```
</details>

## Heatmap

## Carte de fréquentation des stations

::: {.callout-tip}
## Exercice


:::

```{r}
library(lubridate)
library(tidyr)

# Extract the 'hour' from the 'timestamp' column
comptages <- comptages %>% mutate(hour = hour(`Date et heure de comptage`))

# Filter and calculate the mean 'Comptage horaire' for hours between 7 and 10
df1 <- comptages %>%
  filter(hour %in% 7:10) %>%
  group_by(`Identifiant du compteur`) %>%
  summarise(y = mean(`Comptage horaire`, na.rm = TRUE))


df2 <- comptages %>%
  filter(hour %in% 7:10) %>%
  group_by(`Identifiant du compteur`) %>%
  summarise(y = mean(`Comptage horaire`, na.rm = TRUE))

# Merge with 'compteurs' based on 'id_compteur'
df1 <- compteurs %>%
  left_join(
    df1,
    by = c("id_compteur" = "Identifiant du compteur")
  ) %>%
  drop_na(y)

df2 <- compteurs %>%
  left_join(
    df2, by = c("id_compteur" = "Identifiant du compteur")
  ) %>%
  drop_na(y)
```


```{r}
#| eval: false
library(mapsf)

mf_map(arrondissements %>% st_transform(4326))
# plot population
mf_map(
  x = df1,
  var = c("y","y"),
  type = "prop_choro",
  nbreaks = 4
  #inches = 0.25,
  #col = "brown4",
  #leg_pos = "bottomleft2",
  #leg_title = "Total population"
)
```

